---
title: Rumen bacterial communities can be acclimated faster to high concentrate diets
  than currently implemented feedlot programs
author: "Christopher L. Anderson (canderson30@unl.edu)"
output:
  github_document: default
  html_notebook: default
  html_document: default
---

## Data Curation

Raw data is provided in the github repository already, but need to download other files essential to the analysis, including the SILVA v119 reference files. Additionally, here we 'unbundle' and install packages that are needed for the analysis with Packrat.


```{r, results="hide"}
# packrat::clean()
# packrat::bundle()
# packrat::unbundle()
# sessionInfo()

library(Biostrings)
library(stringr)
library(tidyverse)
library(XML)
library(forcats)
library(rmarkdown)
library(knitr)
library(grid)

source("functions.R")

```

```{r knitr.settings, eval=T, echo=F, cache=TRUE}
sessionInfo()
opts_chunk$set("tidy" = T)
opts_chunk$set("echo" = T)
opts_chunk$set("eval" = T)
opts_chunk$set("warning" = F)
opts_chunk$set("cache" = T)
```

```{r, engine="bash", results="hide"}
tar -zxvf rumen_acclimation.tar.gz

curl -LO 'http://www.mothur.org/w/images/2/27/Silva.nr_v119.tgz'
tar -zxvf Silva.nr_v119.tgz
rm -rf Silva.nr_v119.tgz silva.nr_v119.tax
```

## Demulitplex and Quality Control

The code chunk below demulitplexes the sequencing library using the provided mapping file then trims off the reverse primer.  Subseqeuntly, we trim the seqeunces to a fixed length of 400 basepairs to improve OTU picking downstream. Finally, the sequences are reverse complemented.

```{r, engine="bash", results="hide"}
split_libraries.py -m mapping.txt -f rumen_acclimation.fasta -b hamming_8 -l 0 -L 1000 -M 1 -o demultiplex

truncate_reverse_primer.py -f demultiplex/seqs.fna -o trunc_primer -m mapping.txt -z truncate_only -M 2
  
mothur "#trim.seqs(fasta=trunc_primer/seqs_rev_primer_truncated.fna, minlength=400)"
  
fastx_trimmer -i trunc_primer/seqs_rev_primer_truncated.trim.fasta -l 400 -o qc_trim.fasta
 
mothur "#reverse.seqs(fasta=qc_trim.fasta)"
```

## OTU Picking

Convert the fasta file headers from QIIME format to a format that works with UPARSE to generate the OTU table.

```{r}
seqs <- readDNAStringSet("qc_trim.rc.fasta", format = "fasta")
 
names(seqs) <- str_extract(names(seqs), "R\\d+_\\d+") %>% 
  str_split("_") %>%
  map_chr(~str_c("rumen", .x[[2]], ";barcode=", .x[[1]]))
 
writeXStringSet(seqs, "qc_trim_rc_format.fasta", format = "fasta")
```
 
Use UPARSE suite of tools to pick OTUs.

```{r, engine="bash"}
gzip -d gold.fasta.gz
mkdir usearch_out

usearch -derep_fulllength qc_trim_rc_format.fasta -sizeout -output usearch_out/derep.fasta

usearch -sortbysize usearch_out/derep.fasta -minsize 2 -output usearch_out/derep_sort.fasta

usearch -cluster_otus usearch_out/derep_sort.fasta -otus usearch_out/otus1.fasta

usearch -uchime_ref usearch_out/otus1.fasta -db gold.fasta -strand plus -nonchimeras usearch_out/otus1_no_chim.fasta

python usearch_python_scripts/fasta_number.py usearch_out/otus1_no_chim.fasta > usearch_out/otus2.fasta

usearch -usearch_global qc_trim_rc_format.fasta -db usearch_out/otus2.fasta -strand plus -id 0.97 -uc usearch_out/otu_map.uc

python usearch_python_scripts/uc2otutab.py usearch_out/otu_map.uc > otu_table.txt
```

## Assign and Summarize Taxonomy

```{r, engine="bash"}
assign_taxonomy.py -i usearch_out/otus2.fasta -t anaconda/envs/rumenEnv/lib/python2.7/site-packages/qiime_default_reference/gg_13_8_otus/taxonomy/97_otu_taxonomy.txt -r anaconda/envs/rumenEnv/lib/python2.7/site-packages/qiime_default_reference/gg_13_8_otus/rep_set/97_otus.fasta -o assign_taxa -m mothur
```

Add the taxa to the OTU table with the column header "taxonomy" and output the resulting file to biom format.

```{r, engine='bash'}
awk 'NR==1; NR > 1 {print $0 | "sort"}' otu_table.txt > otu_table_sort.txt 

sort assign_taxa/otus2_tax_assignments.txt > assign_taxa/otus2_tax_assignments_sort.txt

{ printf '\ttaxonomy\t\t\n'; cat assign_taxa/otus2_tax_assignments_sort.txt ; }  > assign_taxa/otus2_tax_assignments_sort_label.txt

paste otu_table_sort.txt <(cut -f 2 assign_taxa/otus2_tax_assignments_sort_label.txt) > otu_table_tax.txt

rm otu_table_sort.txt

biom convert --table-type "OTU table" -i otu_table_tax.txt -o otu_table_tax.biom --process-obs-metadata taxonomy --to-json
```

Summarize taxonomy based on those assignments that go to at least the genera and family levels.

```{r, engine="bash"}
biom convert --table-type "OTU table" -i otu_table_tax_final.biom -o otu_table_tax_final.txt --header-key taxonomy --output-metadata-id "taxonomy" --to-tsv

# summarize by genera
head -n 2 otu_table_tax_final.txt > otu_table_tax_genus.txt

grep "g__[a-zA-Z0-9]" otu_table_tax_final.txt >> otu_table_tax_genus.txt

biom convert --table-type "OTU table" -i otu_table_tax_genus.txt -o otu_table_tax_genus.biom --process-obs-metadata taxonomy --to-json

biom summarize-table -i otu_table_tax_genus.biom -o otu_table_tax_genus_summary.txt

# summarize by family
head -n 2 otu_table_tax_final.txt > otu_table_tax_family.txt

grep "f__[a-zA-Z0-9]" otu_table_tax_final.txt >> otu_table_tax_family.txt 

biom convert --table-type "OTU table" -i otu_table_tax_family.txt -o otu_table_tax_family.biom --process-obs-metadata taxonomy --to-json

biom summarize-table -i otu_table_tax_family.biom -o otu_table_tax_family_summary.txt
```

## Filter Reads

Two of the samples were collected and sequenced twice. Unsure sure why, but lets remove the duplicate with the lower depth - samples R6 and R19.

```{r, engine='bash'}
printf "R6\nR19" > remove_samples.txt

filter_samples_from_otu_table.py -i otu_table_tax.biom -o otu_table_tax_filter.biom --sample_id_fp remove_samples.txt --negate_sample_id_fp

biom summarize-table -i otu_table_tax_filter.biom -o otu_table_tax_filter_summary.txt
```

Align the sequences using the SILVA reference within mothur and view the alignment summary.

```{r, engine='bash', results='hide'}
mothur "#align.seqs(fasta=usearch_out/otus2.fasta, reference=silva.nr_v119.align)"

mv usearch_out/otus2.align ./

mothur "#summary.seqs(fasta=otus2.align)"
```

Use R to find the OTUs with poor alignments via the summary file generated above. Decided to remove OTUs that did not end exactly at position 13125 (remember this is the end we sequenced off of...) and started before position 1726.

```{r}
summary <- read_tsv("otus2.summary")
filtered_otus <- filter(summary, end == 13125 & start > 1726) %>% 
  select(seqname)
write_tsv(filtered_otus, "remove_otus.txt", col_names = F)
```

Next, remove those OTUs that did not align well from the OTU table, and additionally, those OTUs with a Cyanobacteria classification. UPARSE should have removed sinlgeton OTUs, but while we are removing OTUs we want to double check this is the case (-n 2 parameter).

```{r, engine='bash'}
filter_otus_from_otu_table.py -i otu_table_tax_filter.biom -o otu_table_tax_filter2.biom -e remove_otus.txt -n 2 --negate_ids_to_exclude

filter_taxa_from_otu_table.py -i otu_table_tax_filter2.biom -o otu_table_tax_final.biom -n p__Cyanobacteria

biom summarize-table -i otu_table_tax_final.biom -o otu_table_tax_final_summary.txt
```

## Phylogenetic Tree of OTU Representative Sequences

Leaving the OTUs that we removed from the OTU table within the aligned file is fine for downstream analyses. Using that algined file here we generate a phylogenetic tree using the clearcut application in mothur. For this to work, clearcut requires ID lengths greater than ~10 characters. To account for this, we simply add 10 'A's to the front of all sequence names. We then remove the 'A's after the tree is formed.

```{r, engine='bash', results='hide'}
sed -i -e 's/>/>AAAAAAAAAA/g' otus2.align

mothur "#dist.seqs(fasta=otus2.align, output=lt)"

mothur "#clearcut(phylip=otus2.phylip.dist)"

sed -i -e 's/AAAAAAAAAA//g' otus2.phylip.tre
```

## Rarefaction Curves and Alpha Diversity

We wanted to look at the sequencing depth of each sample by monitoring the number of novel OTUs encountered as sample depth is increased. Setup here is for a depth roughly equivalent to least sample seqeunced within a step-up diet in our study so we can visually see full depth to give us an idea if the curves were plateauing. Also, here we compare alpha diversity (observed OTUs and chao1 index) with all samples at the sample depth.

Remember, from QIIME notes: "If the lines for some categories do not extend all the way to the right end of the x-axis, that means that at least one of the samples in that category does not have that many sequences."

```{r, engine='bash'}
multiple_rarefactions.py -i otu_table_tax_final.biom -o alpha_rare -m 10 -x 6600 -s 500 -n 10
 
alpha_diversity.py -i alpha_rare/ -o alpha_rare_otu_chao -m observed_otus,chao1
 
collate_alpha.py -i alpha_rare_otu_chao/ -o alpha_rare_collate
 
make_rarefaction_plots.py -i alpha_rare_collate/ -m mapping.txt -e stderr --generate_average_tables -b Treatment -w -o alpha_rare_collate_avgtable
 
multiple_rarefactions_even_depth.py -i otu_table_tax_final.biom -n 10 -d 2160 -o mult_even
 
alpha_diversity.py -i mult_even/ -o alpha_even -m observed_otus,chao1,goods_coverage 
 
collate_alpha.py -i alpha_even -o alpha_even_collate

alpha_diversity.py -i otu_table_tax_final.biom -o goods.txt -m goods_coverage
```

```{r, fig.width=10, fig.height=10}
rare_html <- readHTMLTable("alpha_rare_collate_avgtable/rarefaction_plots.html")
rare_html$rare_data[rare_html$rare_data == "nan"] <- NA
colnames(rare_html$rare_data) <- c("treatment", "seqs", "chao_avg", "chao_err", "otu_avg", "otu_err")
rare_df <- as_tibble(rare_html$rare_data)
rare_df <- rare_df %>% 
  mutate_at(vars(-treatment), as.character) %>% 
  mutate_at(vars(-treatment), as.double) %>% 
  mutate(diet = if_else(str_detect(treatment, "^C"), "Corn", "RAMP")) %>%
  mutate(plot_color = case_when(
    str_detect(treatment, ("[CR]1")) ~ "#FF0000",
    str_detect(treatment, ("[CR]2")) ~ "#BF003F",
    str_detect(treatment, ("[CR]3")) ~ "#7F007F",
    str_detect(treatment, ("[CR]4")) ~ "#3F00BF",
    str_detect(treatment, ("[CR]F")) ~ "#0000FF"
  )) %>% 
  group_by(diet)

plot_color_vect <- rare_df$plot_color
names(plot_color_vect) <- rare_df$treatment

rare_otu_plot <- ggplot(rare_df, aes(x = seqs, y = otu_avg, color = treatment, group = treatment, ymin = otu_avg - otu_err, ymax = otu_avg + otu_err)) +
  facet_grid(~diet) +
  geom_line(position = position_dodge(width = 275)) + 
  geom_pointrange(position = position_dodge(width = 275), size = 0.3) +
  scale_color_manual(values = plot_color_vect) +
  labs(x = "Sequences per Sample", y = "Mean Observed OTUs") +
  theme(legend.title = element_blank(), 
        text = element_text(size = 6))

rare_chao_plot <- ggplot(rare_df, aes(x = seqs, y = chao_avg, color = treatment, group = treatment, ymin = chao_avg - chao_err, ymax = chao_avg + chao_err)) +
  facet_grid(~diet) +
  geom_line(position = position_dodge(width = 275)) + 
  geom_pointrange(position = position_dodge(width = 275), size = 0.3) +
  scale_color_manual(values = plot_color_vect) +
  labs(x = "Sequences per Sample", y = "Mean Observed OTUs") +
  theme(legend.title = element_blank(), 
        text = element_text(size = 6))

alpha_col_names <- c("CF_332", "R3_259", "R2_343", "R4_343", "R4_259", "C3_346", "C4_332", "R1_222", "CF_346", "RF_343", "RF_222", "C3_332", "R2_222", "R1_343", "R3_343", "C1_346", "C2_332", "R2_259", "R3_222", "C1_332", "C2_346", "R4_222", "RF_259", "R1_259", "C4_346")

alpha_chao <- read_tsv("alpha_even_collate/chao1.txt")
alpha_chao <- select(alpha_chao, starts_with("R"))
names(alpha_chao) <- alpha_col_names
alpha_chao_t <- enframe(as.list(alpha_chao))
alpha_chao_plot <- alpha_chao_t %>% 
  mutate(means = map_dbl(value, mean)) %>% 
  mutate(sds = map_dbl(value, sd)) %>% 
  mutate(diet = if_else(str_detect(name, "^C"), "Corn", "RAMP")) %>% 
  mutate(treatment = str_sub(name, 1, 2)) %>% 
  ggplot(., aes(x = treatment, y = means)) +
    facet_wrap(~diet) +
    geom_point(size = 2) + 
    labs(x = "", y = "Mean Chao1 Index") +
    theme(legend.title = element_blank(),text = element_text(size = 6))

alpha_otu <- read_tsv("alpha_even_collate/observed_otus.txt")
alpha_otu <- select(alpha_otu, starts_with("R"))
names(alpha_otu) <- alpha_col_names
alpha_otu_t <- enframe(as.list(alpha_otu))
alpha_otu_plot <- alpha_otu_t %>% 
  mutate(means = map_dbl(value, mean)) %>% 
  mutate(sds = map_dbl(value, sd)) %>% 
  mutate(diet = if_else(str_detect(name, "^C"), "Corn", "RAMP")) %>% 
  mutate(treatment = str_sub(name, 1, 2)) %>% 
  ggplot(., aes(x = treatment, y = means)) +
    facet_wrap(~diet) +
    geom_point(size = 2) + 
    labs(x = "", y = "Mean Observed OTUs") +
    theme(legend.title = element_blank(),text = element_text(size = 6))

multiplot(rare_otu_plot, rare_chao_plot, alpha_otu_plot, alpha_chao_plot, cols = 2)

pdf("FigureS2.pdf", height = 12, width = 12)
multiplot(rare_otu_plot, rare_chao_plot, alpha_otu_plot, alpha_chao_plot, cols = 2)
dev.off()

```

## Beta Diversity

Investigate the influence of Corn and RAMP based treatments on beta diversity independently.

```{r, engine='bash'}
biom summarize-table -i otu_table_tax_final.biom -o otu_table_tax_final_summary.txt

beta_diversity_through_plots.py -i otu_table_tax_final.biom -o beta_div -t otus2.phylip.tre -m mapping.txt -p qiime_parameters_working.txt -e 2160

split_otu_table.py -i otu_table_tax_final.biom -o split_total -m mapping.txt -f Diet
 
biom summarize-table -i split_total/otu_table_tax_final__Diet_Corn__.biom -o split_total/corn_summarize.txt

biom summarize-table -i split_total/otu_table_tax_final__Diet_RAMP__.biom -o split_total/ramp_summarize.txt

beta_diversity_through_plots.py -i split_total/otu_table_tax_final__Diet_Corn__.biom -o corn_beta_div -t otus2.phylip.tre -m mapping.txt -p qiime_parameters_working.txt -e 2160

beta_diversity_through_plots.py -i split_total/otu_table_tax_final__Diet_RAMP__.biom -o ramp_beta_div -t otus2.phylip.tre -m mapping.txt -p qiime_parameters_working.txt -e 2959
```


